La notaci√≥n O o notaci√≥n Big O es una forma de describir la complejidad computacional de un algoritmo en t√©rminos de tiempo o espacio. Esta notaci√≥n nos ayuda a entender c√≥mo se comporta un algoritmo a medida que el tama√±o de los datos de entrada (n) crece, y se enfoca principalmente en los t√©rminos dominantes que afectan el rendimiento en escenarios de gran escala.

Generalidades de la notaci√≥n O:
Qu√© mide la notaci√≥n O:

Complejidad temporal: Indica cu√°nto tiempo toma un algoritmo para ejecutarse en funci√≥n del tama√±o de la entrada.
Complejidad espacial: Indica cu√°nta memoria o espacio adicional utiliza un algoritmo durante su ejecuci√≥n.
Prop√≥sito:

La notaci√≥n Big O ignora constantes y t√©rminos de menor importancia para centrarse en el comportamiento general del algoritmo cuando el tama√±o de la entrada crece indefinidamente.
Se utiliza para comparar la eficiencia de diferentes algoritmos y entender cu√°l es m√°s adecuado para grandes vol√∫menes de datos.
Clases comunes de complejidad (en t√©rminos de tiempo):

O(1) ‚Äì Tiempo constante: El algoritmo toma la misma cantidad de tiempo independientemente del tama√±o de la entrada.
Ejemplo: Acceso directo a un elemento en un arreglo.
O(log n) ‚Äì Tiempo logar√≠tmico: El tiempo de ejecuci√≥n crece lentamente a medida que el tama√±o de la entrada aumenta. Generalmente asociado a algoritmos que dividen el problema a la mitad en cada paso (por ejemplo, b√∫squeda binaria).
O(n) ‚Äì Tiempo lineal: El tiempo de ejecuci√≥n crece proporcionalmente al tama√±o de la entrada.
Ejemplo: Recorrer un arreglo de tama√±o n.
O(n log n) ‚Äì Tiempo lineal logar√≠tmico: Es m√°s eficiente que O(n¬≤), pero menos que O(n). Se encuentra en algoritmos de ordenamiento eficientes como Merge Sort o QuickSort.
O(n¬≤) ‚Äì Tiempo cuadr√°tico: El tiempo de ejecuci√≥n crece proporcional al cuadrado del tama√±o de la entrada. Aparece en algoritmos que tienen bucles anidados.
Ejemplo: Ordenamiento burbuja o selecci√≥n en su peor caso.
O(2‚Åø) ‚Äì Tiempo exponencial: El tiempo de ejecuci√≥n crece exponencialmente con el tama√±o de la entrada. Este tipo de complejidad es impr√°ctica para grandes entradas.
Ejemplo: Algoritmos que solucionan problemas mediante prueba y error exhaustiva, como ciertos algoritmos de programaci√≥n din√°mica o de fuerza bruta.
C√≥mo funciona:

Se enfoca en el t√©rmino dominante, ignorando los detalles m√°s peque√±os. Por ejemplo, si un algoritmo tiene una complejidad de 
5
ùëõ
2
+
3
ùëõ
+
10
5n 
2
 +3n+10, se expresa como O(n¬≤), ya que el t√©rmino cuadr√°tico es el que crece m√°s r√°pido a medida que el tama√±o de entrada aumenta.
Escalabilidad:

La notaci√≥n Big O nos ayuda a entender c√≥mo un algoritmo "escala" cuando el tama√±o de la entrada crece. Por ejemplo, un algoritmo con O(n) crece linealmente, mientras que uno con O(n¬≤) se vuelve mucho m√°s lento a medida que aumentan los datos.
Ejemplos pr√°cticos de notaci√≥n Big O:
Buscar un elemento en una lista no ordenada mediante un bucle for toma O(n) porque necesitas revisar cada elemento.
B√∫squeda binaria en una lista ordenada toma O(log n), ya que reduces el espacio de b√∫squeda a la mitad en cada paso.
Ordenamiento burbuja es O(n¬≤), ya que en el peor de los casos, necesita realizar n comparaciones para cada uno de los n elementos.
Resumen de las principales categor√≠as de Big O:
Notaci√≥n  	Nombre	                  Ejemplo
O(1)	        Tiempo constante	      Acceder a un √≠ndice espec√≠fico de un arreglo
O(log n)	    Tiempo logar√≠tmico	    B√∫squeda binaria
O(n)	        Tiempo lineal	          Recorrer una lista
O(n log n)	  Tiempo lineal           log	Merge Sort, QuickSort
O(n¬≤)	        Tiempo cuadr√°tico	      Ordenamiento burbuja
O(2‚Åø)	        Tiempo exponencial	    Algoritmos de fuerza bruta en problemas de optimizaci√≥n
En resumen, la notaci√≥n Big O es una herramienta clave en la teor√≠a de algoritmos que nos permite analizar su eficiencia y escalabilidad en funci√≥n del tama√±o de los datos.











